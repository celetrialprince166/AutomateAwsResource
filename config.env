#!/usr/bin/env bash
#
# config.env - Centralized Configuration for AWS Automation Scripts
#
# This file is the SINGLE SOURCE OF TRUTH for all configuration values.
# All scripts source this file to ensure consistency across the entire project.
#
# CRITICAL: The PROJECT_TAG value MUST be consistent everywhere for cleanup to work!
#
# Usage:
#   source config.env
#   # or via common.sh which sources this automatically
#   source lib/common.sh
#
# Override at runtime:
#   AWS_REGION=eu-west-1 ./scripts/create_ec2.sh
#
# Author: AutomationLab Project
# Version: 1.0.0
#

# ============================================================================
# AWS Configuration
# ============================================================================

# AWS Region - where resources will be created
# Default: eu-west-1 (Ireland) - most services available, free tier friendly
export AWS_REGION="${AWS_REGION:-${AWS_DEFAULT_REGION:-eu-west-1}}"

# AWS CLI Profile - use named profile or default
export AWS_PROFILE="${AWS_PROFILE:-default}"

# ============================================================================
# Resource Naming Conventions (DRY - Single Prefix for All)
# ============================================================================

# Master prefix for all resources - ensures consistent naming
export NAME_PREFIX="${NAME_PREFIX:-automationlab}"

# ============================================================================
# Tagging Strategy (CRITICAL FOR CLEANUP!)
# ============================================================================

# IMPORTANT: These values MUST be used everywhere for cleanup to work correctly!
# The cleanup script filters by these exact values.

# Primary tag key used for all resources
export TAG_KEY="${TAG_KEY:-Project}"

# Primary tag value - THE AUTHORITATIVE VALUE
# WARNING: Changing this will break cleanup of existing resources!
export PROJECT_TAG="${PROJECT_TAG:-AutomationLab}"

# ============================================================================
# EC2 Configuration
# ============================================================================

# SSH Key pair name
export KEY_NAME="${KEY_NAME:-${NAME_PREFIX}-key}"

# EC2 instance type (t3.micro is free tier eligible)
export INSTANCE_TYPE="${INSTANCE_TYPE:-t3.micro}"

# AMI lookup via SSM Parameter Store (Amazon Linux 2)
# This ensures we always get the latest patched AMI
export AMI_SSM_PARAMETER="${AMI_SSM_PARAMETER:-/aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2}"

# Instance name tag (for display in console)
export INSTANCE_NAME="${INSTANCE_NAME:-${NAME_PREFIX}-instance}"

# ============================================================================
# Security Group Configuration
# ============================================================================

# Security group name
export SECURITY_GROUP_NAME="${SECURITY_GROUP_NAME:-${NAME_PREFIX}-sg}"

# Security group description
export SECURITY_GROUP_DESC="${SECURITY_GROUP_DESC:-Security group for AutomationLab project - allows SSH and HTTP}"

# Allowed inbound ports (SSH and HTTP as per project requirements)
export SG_SSH_PORT="${SG_SSH_PORT:-22}"
export SG_HTTP_PORT="${SG_HTTP_PORT:-80}"

# CIDR for inbound rules (0.0.0.0/0 = anywhere - use with caution in production!)
export SG_INGRESS_CIDR="${SG_INGRESS_CIDR:-0.0.0.0/0}"

# ============================================================================
# S3 Bucket Configuration
# ============================================================================

# Bucket name prefix (will be appended with timestamp for uniqueness)
export BUCKET_PREFIX="${BUCKET_PREFIX:-${NAME_PREFIX}-bucket}"

# Sample file to upload
export S3_SAMPLE_FILE="${S3_SAMPLE_FILE:-welcome.txt}"
export S3_SAMPLE_CONTENT="${S3_SAMPLE_CONTENT:-Welcome to AutomationLab - AWS Resource Automation with Bash}"

# ============================================================================
# State Management
# ============================================================================

# State backend type: "local" or "s3"
# - local: State stored in .state/ directory (default)
# - s3: State stored in S3 bucket with versioning (recommended for teams/production)
export STATE_BACKEND="${STATE_BACKEND:-s3}"

# Directory for local state files (also used as cache for S3 backend)
export STATE_DIR="${STATE_DIR:-.state}"

# Current workspace name (allows multiple environments)
export WORKSPACE="${WORKSPACE:-default}"

# State file path (derived from workspace)
export STATE_FILE="${STATE_FILE:-${STATE_DIR}/${WORKSPACE}.json}"

# Lock file for preventing concurrent operations
export STATE_LOCK_FILE="${STATE_LOCK_FILE:-${STATE_DIR}/${WORKSPACE}.lock}"

# ============================================================================
# S3 Remote State Backend Configuration
# ============================================================================

# S3 bucket name for remote state storage
# If empty and STATE_BACKEND=s3, bucket will be auto-created with name:
#   ${NAME_PREFIX}-tfstate-${AWS_ACCOUNT_ID}
export STATE_S3_BUCKET="${STATE_S3_BUCKET:-}"

# S3 key (path) for state file within the bucket
export STATE_S3_KEY="${STATE_S3_KEY:-state/${WORKSPACE}.json}"

# Region for state bucket (defaults to main AWS_REGION)
export STATE_S3_REGION="${STATE_S3_REGION:-${AWS_REGION}}"

# Enable server-side encryption (SSE-S3)
export STATE_S3_ENCRYPT="${STATE_S3_ENCRYPT:-true}"

# Lock timeout in seconds (how long to wait for lock before failing)
export STATE_LOCK_TIMEOUT="${STATE_LOCK_TIMEOUT:-60}"

# ============================================================================
# Logging Configuration
# ============================================================================

# Log level: DEBUG, INFO, WARN, ERROR
export LOG_LEVEL="${LOG_LEVEL:-INFO}"

# Log directory
export LOG_DIR="${LOG_DIR:-./logs}"

# Enable/disable file logging
export LOG_TO_FILE="${LOG_TO_FILE:-true}"

# ============================================================================
# Behavior Flags
# ============================================================================

# Skip confirmation prompts (use with caution!)
export AUTO_APPROVE="${AUTO_APPROVE:-false}"

# Dry run mode - show what would be done without doing it
export DRY_RUN="${DRY_RUN:-false}"

# Verbose output (sets LOG_LEVEL=DEBUG)
export VERBOSE="${VERBOSE:-false}"

# Apply verbose flag to log level
if [[ "${VERBOSE}" == "true" ]]; then
    export LOG_LEVEL="DEBUG"
fi

# ============================================================================
# Timeouts and Retries
# ============================================================================

# Maximum retries for transient AWS API errors
export MAX_RETRIES="${MAX_RETRIES:-3}"

# Initial backoff delay in seconds (doubles each retry)
export RETRY_DELAY="${RETRY_DELAY:-2}"

# Timeout for AWS waiter commands (in seconds)
export WAITER_TIMEOUT="${WAITER_TIMEOUT:-300}"

# ============================================================================
# Validation
# ============================================================================

# Validate critical configuration on source
_validate_config() {
    local errors=0

    # Check AWS region format (basic validation)
    if [[ ! "${AWS_REGION}" =~ ^[a-z]{2}-[a-z]+-[0-9]+$ ]]; then
        echo "WARNING: AWS_REGION '${AWS_REGION}' may not be valid" >&2
    fi

    # Check PROJECT_TAG is not empty
    if [[ -z "${PROJECT_TAG}" ]]; then
        echo "ERROR: PROJECT_TAG cannot be empty" >&2
        errors=$((errors + 1))
    fi

    # Check NAME_PREFIX is not empty and is lowercase
    if [[ -z "${NAME_PREFIX}" ]]; then
        echo "ERROR: NAME_PREFIX cannot be empty" >&2
        errors=$((errors + 1))
    fi

    return ${errors}
}

# Run validation (can be disabled with SKIP_CONFIG_VALIDATION=true)
if [[ "${SKIP_CONFIG_VALIDATION:-false}" != "true" ]]; then
    _validate_config || true
fi

